// Generated by CoffeeScript 1.8.0
(function() {
  var _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(root, factory) {
    if (typeof exports === 'object') {
      return module.exports = factory.call(root);
    } else if (typeof define === 'function' && define.amd) {
      return define(function() {
        return factory.call(root);
      });
    } else {
      return root.evo = factory.call(root);
    }
  })((_ref = typeof window !== "undefined" && window !== null) != null ? _ref : {
    window: this
  }, function() {
    var Base, Cppn, FeedForward, Network, Pool, evo;
    evo = {};
    evo.config = {
      pool: {
        n_genes: 200,
        cross_rate: 0.04,
        mutate_rate: 0.04,
        mutate_amount: 0.10,
        size: 100,
        ratios: {
          top: 0.20,
          mutate: 0.20,
          cross: 0.30,
          random: 0.05,
          meld: 0.20
        },
        on_breed: function() {},
        on_spawn: void 0
      },
      network: {
        hidden_layers: 2,
        hidden_nodes: 4,
        output_nodes: 3,
        input_nodes: 2
      }
    };
    evo.util = {
      random: function(min, max) {
        if (min == null) {
          min = -1;
        }
        if (max == null) {
          max = 1;
        }
        return (Math.random() * (max - min)) + min;
      },
      sin: function(x, freq, phase) {
        if (freq == null) {
          freq = 1;
        }
        if (phase == null) {
          phase = 0;
        }
        return Math.sin(x * freq * 6.2832 + phase);
      },
      gaussian: function(x, mu, sigma) {
        return Math.exp(-(Math.pow(mu - x, 2)) * sigma);
      },
      linear: function(x, m, b) {
        return (x + b) * m;
      },
      flatten: function(x) {
        if (x > 1) {
          return 1;
        }
        if (x < -1) {
          return -1;
        }
        return x;
      },
      tanh: function(x) {
        var x1, x2;
        if (-3 > x || x > 3) {
          return evo.util.flatten(x);
        } else {
          x1 = Math.exp(x);
          x2 = Math.exp(-x);
          return (x1 - x2) / (x1 + x2);
        }
      },
      sample: function(array) {
        return array[Math.floor(Math.random() * array.length)];
      },
      shuffle: function(array) {
        var index, length, rand, shuffled, _i, _ref1;
        length = array.length;
        shuffled = Array(length);
        for (index = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = 0 <= _ref1 ? ++_i : --_i) {
          rand = Math.floor(Math.random() * index);
          if (rand !== index) {
            shuffled[index] = shuffled[rand];
          }
          shuffled[rand] = array[index];
        }
        return shuffled;
      },
      clone: function(obj) {
        var attr, copy;
        if (null === obj || "object" !== typeof obj) {
          return obj;
        }
        copy = obj.constructor();
        for (attr in obj) {
          if (obj.hasOwnProperty(attr)) {
            copy[attr] = obj[attr];
          }
        }
        return copy;
      },
      extend: function(destination, source) {
        var property;
        destination = evo.util.clone(destination);
        if (source == null) {
          return destination;
        }
        for (property in source) {
          if (source[property] && source[property].constructor && source[property].constructor === Object) {
            destination[property] = destination[property] || {};
            arguments.callee(destination[property], source[property]);
          } else {
            destination[property] = source[property];
          }
        }
        return destination;
      }
    };
    Base = (function() {
      function Base() {}

      Base.prototype.config = {};

      Base.prototype.on = function(name, fn) {
        this.config['on_' + name] = fn;
        return this;
      };

      Base.prototype.trigger = function(name, args) {
        if (args == null) {
          args = null;
        }
        if (this.config['on_' + name] != null) {
          return this.config['on_' + name].call(this, args);
        }
      };

      return Base;

    })();
    Pool = (function(_super) {
      __extends(Pool, _super);

      function Pool(config) {
        var i, _i, _ref1;
        this.config = config;
        this.generation = 0;
        this.pool = [];
        this.breedpool = [];
        this.last_genes = {};
        for (i = _i = 1, _ref1 = this.config.size; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
          this.pool.push(this.fresh());
        }
        this.prev_pool = this.pool.slice(0);
        this.average = 0;
      }

      Pool.prototype.fresh = function() {
        var i, _i, _ref1, _results;
        _results = [];
        for (i = _i = 1, _ref1 = this.config.n_genes; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
          _results.push(evo.util.random() * this.config.mutate_amount);
        }
        return _results;
      };

      Pool.prototype.clone = function(genes) {
        return genes.slice(0);
      };

      Pool.prototype.mutate = function(genes) {
        var g, i, new_genes, _i, _len;
        new_genes = [];
        for (i = _i = 0, _len = genes.length; _i < _len; i = ++_i) {
          g = genes[i];
          new_genes[i] = genes[i];
          if (Math.random() < this.config.mutate_rate) {
            new_genes[i] += evo.util.random() * this.config.mutate_amount;
          }
        }
        return new_genes;
      };

      Pool.prototype.cross = function(genes1, genes2) {
        var flip, g, i, new_genes, _i, _len;
        new_genes = [];
        flip = false;
        for (i = _i = 0, _len = genes1.length; _i < _len; i = ++_i) {
          g = genes1[i];
          if (Math.random() < this.config.cross_rate) {
            flip = !flip;
          }
          new_genes.push((flip ? genes1[i] : genes2[i]));
        }
        return new_genes;
      };

      Pool.prototype.meld = function(genes1, genes2) {
        var g, i, new_genes, _i, _len;
        new_genes = [];
        for (i = _i = 0, _len = genes1.length; _i < _len; i = ++_i) {
          g = genes1[i];
          new_genes.push((genes1[i] + genes2[i]) / 2);
        }
        return new_genes;
      };

      Pool.prototype.spawn = function() {
        var genes, spec;
        genes = this.next();
        spec = this.trigger('spawn', genes);
        spec.genes = genes;
        spec.score = 0;
        spec.report = (function(_this) {
          return function() {
            return _this.report(spec);
          };
        })(this);
        return spec;
      };

      Pool.prototype.next = function() {
        if (this.pool.length === 0) {
          if (this.breedpool.length > 0) {
            this.generate();
          } else {
            return this.last = this.fresh();
          }
        }
        return this.last = this.pool.pop();
      };

      Pool.prototype.report = function(genes, score) {
        if (score == null) {
          score = 0;
        }
        if ((genes.score != null) && (genes.genes != null)) {
          score = genes.score;
          genes = genes.genes;
        }
        if (genes == null) {
          genes = this.last_genes;
        }
        return this.breedpool.push({
          genes: genes,
          score: score
        });
      };

      Pool.prototype.mean = function(pool) {
        var a, avg, _i, _len;
        avg = 0;
        for (_i = 0, _len = pool.length; _i < _len; _i++) {
          a = pool[_i];
          avg += a.score;
        }
        return avg /= pool.length;
      };

      Pool.prototype.generate = function() {
        var a, g1, g2, i, size, top_pool, _i, _j, _k, _l, _len, _m, _ref1, _ref2, _ref3, _ref4;
        this.pool = [];
        this.average = this.mean(this.breedpool);
        this.breedpool = this.breedpool.sort(function(a, b) {
          return a.score - b.score;
        });
        top_pool = this.breedpool.reverse().slice(0, +(this.config.ratios.top * this.config.size) + 1 || 9e9);
        size = this.config.size;
        if (size < 1) {
          size = 0;
        }
        for (_i = 0, _len = top_pool.length; _i < _len; _i++) {
          a = top_pool[_i];
          this.pool.push(this.clone(a.genes));
        }
        for (i = _j = 1, _ref1 = this.config.ratios.mutate * size; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
          this.pool.push(this.mutate(evo.util.sample(top_pool).genes));
        }
        for (i = _k = 1, _ref2 = this.config.ratios.cross * size; 1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
          g1 = evo.util.sample(top_pool).genes;
          g2 = evo.util.sample(top_pool).genes;
          this.pool.push(this.cross(g1, g2));
        }
        for (i = _l = 1, _ref3 = this.config.ratios.meld * size; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 1 <= _ref3 ? ++_l : --_l) {
          g1 = evo.util.sample(top_pool).genes;
          g2 = evo.util.sample(top_pool).genes;
          this.pool.push(this.meld(g1, g2));
        }
        for (i = _m = 1, _ref4 = this.config.ratios.random * size; 1 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 1 <= _ref4 ? ++_m : --_m) {
          this.pool.push(this.clone(evo.util.sample(this.breedpool).genes));
        }
        while (this.pool.length < size) {
          this.pool.push(this.fresh());
        }
        this.generation++;
        this.prev_pool = this.pool.map(function(g) {
          return g.map(function(d) {
            return Math.round(d * 100) / 100;
          });
        });
        this.pool = evo.util.shuffle(this.pool);
        this.trigger('breed');
        return this.breedpool = [];
      };

      Pool.prototype.load = function(genes) {
        this.pool = genes.slice(0);
        return this.breedpool = [];
      };

      return Pool;

    })(Base);
    evo.pool = function(config) {
      config = evo.util.extend(evo.config.pool, config);
      return new Pool(config);
    };
    Network = (function() {
      function Network(genes, config) {
        this.config = config;
      }

      Network.prototype.calc = function(input) {};

      return Network;

    })();
    Cppn = (function(_super) {
      __extends(Cppn, _super);

      Cppn.node_fn = [
        evo.util.gaussian, evo.util.sin, function(x, m, b) {
          return evo.util.tanh(evo.util.linear(x, m, b));
        }
      ];

      Cppn.prototype.get_fn = function(gene) {
        var index;
        index = Math.round(Math.abs(gene) * Cppn.node_fn.length) % Cppn.node_fn.length;
        return Cppn.node_fn[index];
      };

      function Cppn(genes, config) {
        var copy, i, j, _i, _j, _ref1, _ref2;
        this.config = config;
        this.node_fn = [];
        copy = genes.slice(0);
        for (i = _i = 0, _ref1 = this.config.hidden_layers - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          this.node_fn[i] = [];
          for (j = _j = 0, _ref2 = this.config.hidden_nodes - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            this.node_fn[i].push(this.get_fn(copy.pop()));
          }
        }
        this.weights = copy.slice(0);
      }

      Cppn.prototype.calc = function(input) {
        var copy, hidden_weights, i, j, k, layer_size, output, x, _i, _j, _k, _l, _len, _m, _n, _o, _p, _q, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
        layer_size = this.config.hidden_nodes;
        copy = this.weights.slice(0);
        hidden_weights = [];
        for (k = _i = 0, _ref1 = this.config.hidden_layers - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; k = 0 <= _ref1 ? ++_i : --_i) {
          hidden_weights[k] = [];
          for (i = _j = 0, _ref2 = this.config.hidden_nodes - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            hidden_weights[k][i] = 0;
          }
        }
        for (_k = 0, _len = input.length; _k < _len; _k++) {
          x = input[_k];
          for (i = _l = 0, _ref3 = this.config.hidden_nodes - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
            hidden_weights[0][i] += x * copy.pop();
          }
        }
        for (k = _m = 0, _ref4 = this.config.hidden_layers - 2; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; k = 0 <= _ref4 ? ++_m : --_m) {
          for (i = _n = 0, _ref5 = this.config.hidden_nodes - 1; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; i = 0 <= _ref5 ? ++_n : --_n) {
            hidden_weights[k][i] = this.node_fn[k][i](hidden_weights[k][i], copy.pop(), copy.pop());
            if (!(k + 1 < this.config.hidden_layers)) {
              continue;
            }
            for (j = _o = 0, _ref6 = this.config.hidden_nodes - 1; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; j = 0 <= _ref6 ? ++_o : --_o) {
              hidden_weights[k + 1][j] += hidden_weights[k][i] * copy.pop();
            }
          }
        }
        output = [];
        for (j = _p = 0, _ref7 = this.config.output_nodes - 1; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
          output[j] = 0;
          for (i = _q = 0, _ref8 = this.config.hidden_nodes - 1; 0 <= _ref8 ? _q <= _ref8 : _q >= _ref8; i = 0 <= _ref8 ? ++_q : --_q) {
            output[j] += hidden_weights[this.config.hidden_layers - 1][i] * copy.pop();
          }
          output[j] = evo.util.tanh(output[j]);
        }
        return output;
      };

      return Cppn;

    })(Network);
    FeedForward = (function(_super) {
      __extends(FeedForward, _super);

      function FeedForward() {
        return FeedForward.__super__.constructor.apply(this, arguments);
      }

      FeedForward.prototype.calc = function(input) {
        var copy, h, hidden_weights, i, j, o, output_weights, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref1, _ref2;
        if (input.length !== this.config.input) {
          throw Error("Inputs dont match. Expected: " + this.config.input + ", Received: " + input.length);
        }
        copy = this.weights.slice(0);
        hidden_weights = [];
        for (j = _i = 0, _ref1 = this.config.hidden_nodes - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; j = 0 <= _ref1 ? ++_i : --_i) {
          hidden_weights[j] = 0;
        }
        output_weights = [];
        for (j = _j = 0, _ref2 = this.config.output_nodes - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
          output_weights[j] = 0;
        }
        for (_k = 0, _len = input.length; _k < _len; _k++) {
          i = input[_k];
          for (j = _l = 0, _len1 = hidden_weights.length; _l < _len1; j = ++_l) {
            h = hidden_weights[j];
            hidden_weights[j] += i * copy.pop();
          }
        }
        for (i = _m = 0, _len2 = hidden_weights.length; _m < _len2; i = ++_m) {
          h = hidden_weights[i];
          hidden_weights[i] += copy.pop();
          hidden_weights[i] = evo.util.tanh(hidden_weights[i]);
          for (j = _n = 0, _len3 = output_weights.length; _n < _len3; j = ++_n) {
            o = output_weights[j];
            output_weights[j] += hidden_weights[i] * copy.pop();
          }
        }
        for (i = _o = 0, _len4 = output_weights.length; _o < _len4; i = ++_o) {
          o = output_weights[i];
          output_weights[i] = evo.util.flatten(output_weights[i]);
        }
        return output_weights;
      };

      return FeedForward;

    })(Network);
    evo.network = function(type, weights, config) {
      config = evo.util.extend(evo.config.network, config);
      if (type === 'feedforward') {
        return new FeedForward(weights, config);
      } else if (type === 'cppn') {
        return new Cppn(weights, config);
      }
    };
    return evo;
  });

}).call(this);
